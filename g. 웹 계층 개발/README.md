# 7. 웹 계층 개발

## Index

## 변경 감지와 병합


### 💡데이터베이스 커서와 페이징의 차이

- createQeury().getResultStream() 이었는데 결국 Proxy 를 Stream 에 담은 상태로 불변성이 보장되어서 하이버네이트가 내부에 RealEntity 값을 심어야 되는데 이작업을 할 수 없으니 애러가 나는것이 맞는건가요? 맞다면, Stream은 어느시점에 사용하는것이 좋은가요..?

> 커서(Cursor) 내용은 아시겠지만 혹시 모르는 분들을 위해서 추가로 설명해둘께요.
List로 바로 받는 일반적인 쿼리의 경우 데이터베이스가 결과물을 애플리케이션에 한번에 모두 전달해줍니다. 그래서 데이터가 100만건이면 모든 데이터가 메모리에 올라오면서 Out Of Memory 이 발생하겠지요. 그래서 우리가 페이징 등으로 조금씩 나누어서 조회합니다.
그런데 정말 100만건을 한번에 조회하고 싶으면 커서라는 기능을 사용하면 됩니다. 이 기능으로 조회하면 데이터베이스는 결과를 내부에 저장해두고 애플리케이션에서 달라고 할 때 마다 조금씩 전송해줍니다. 이렇게 되려면 중요한게 애플리케이션과 DB간에 커넥션이 계속 연결되어있어야 하고, 추가로 DB도 해당 데이터를 어딘가에 보관해두어야 합니다.
이렇게 하면 애플리케이션은 조금씩 데이터를 받기 때문에 Out Of Memory 이 발생하지 않고, 사용한 데이터는 GC 처리하면 됩니다.
이 기능은 실시간 애플리케이션에서는 보통 사용하지 않고, 대량의 데이터를 한번에 처리할 때 사용합니다.
getResultStream()을 사용하면 바로 이 커서 기능이 동작합니다.
이 기능을 통해서 스트림을 받아서 스트림을 하나씩 호출하면 내부에서 Jdbc 드라이버의 next()를 호출해서 데이터를 가저옵니다. 바로 커서 기능이 동작하는 것이지요.
그런데 여기서! The object is already closed 라는 뜻은 뭔가 이 커서 데이터가 끊어저 버렸다는 뜻입니다.
이 커서가 끊어지는 것은 데이터베이스마다 다르지만 일반적으로 커넥션이 종료되거나, 또는 트랜잭션이 커밋되어 버리는 경우입니다. 트랜잭션 커밋의 경우 데이터베이스 마다 다릅니다. 트랜잭션이 커밋되어도 커서를 유지하는 옵션을 제공하기도 합니다.
바로 서비스 계층에서 트랜잭션이 커밋되어서 커서가 끊어저버려서 그렇습니다. 아마 서비스 계층에서 스프림을 돌리면 되고, 트랜잭션이 끝난 컨트롤러에서 스트림을 동작해보면 해당 오류가 발생할꺼에요.
그런데 놀랍게도 H2 데이터베이스는 사실 커서를 지원하지 않습니다. 그냥 커서를 지원하는 것 처럼 보이도록 시뮬레이션 한다고 이해하시면 됩니다.
커서는 데이터베이스 리소스를 오랜시간 많이 잡아먹기 때문에 대량의 데이터를 효과적으로 처리해야 하는 경우에만 사용하는 것을 권장합니다.


### ⭐️폼 객체 vs 엔티티 직접 사용 => 당연히 DTO 사용

요구사항이 정말 단순할 때는 폼 객체( `MemberForm` ) 없이 엔티티( `Member` )를 직접 등록과 수정 화면에서 사용해도 된다. 하지만 화면 요구사항이 복잡해지기 시작하면, 엔티티에 화면을 처리하기 위한 기능이 점점 증 가한다. 결과적으로 엔티티는 점점 화면에 종속적으로 변하고, 이렇게 화면 기능 때문에 지저분해진 엔티티는 결 국 유지보수하기 어려워진다.
실무에서 **엔티티는 핵심 비즈니스 로직만 가지고 있고, 화면을 위한 로직은 없어야 한다**. 화면이나 API에 맞는 폼 객체나 DTO를 사용하자. 그래서 화면이나 API 요구사항을 이것들로 처리하고, 엔티티는 최대한 순수하게 유지 하자.

특히, API 개발을 할 때는 무조건 DTO 를 사용하자!!! 엔티티에 중요한 필드가 추가된다고 할 때, 
1. 중요한 내용을 담는 필드가 외부에 노출이 될 수도 있고,
2. API 의 스펙이 변하게 된다. 그럼 해당 API 를 사용하는 다른 개발자들은 변한 API 의 스펙에 맞게 코드를 수정해야 하는 일이 발생할 수도 있다.